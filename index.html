<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>XCL -> OBJ Exporter</title>
  <style>
  /* lightweight, system-native font stack */
  html, body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 14px;
    line-height: 1.45;
    color: #111;
    margin: 0;
    padding: 12px;
  }

  h1 {
    font-size: 20px;
    margin: 0 0 8px 0;
    font-weight: 600;
  }

  #log {
    margin-top: 12px;
    white-space: pre-wrap; /* preserves your log newlines */
    font-family: monospace; /* keep logs readable */
    font-size: 13px;
    background: #f6f7f8;
    padding: 8px;
    border-radius: 6px;
  }

  button, input[type="file"] {
    font-family: inherit; /* match controls to page */
    font-size: 13px;
  }
</style>
</head>
<body>
  <h1>XCL -> OBJ Exporter</h1>
  <p>Source code and hosting is shown <a href="https://github.com/n123git/yw-xcl">on my github!</a></p>
  <input type="file" id="fileInput" />
  <button id="exportBtn" disabled>Export OBJ</button>
  <label>
  <input type="checkbox" id="showVertices" checked>
  Show Vertices
</label>
<label>
  <input type="checkbox" id="showTriangles" checked>
  Show Triangles
</label>

  <div id="log"></div>
<script>
function readuint32le(offset, blob) {
  return (
    blob[offset] |
    (blob[offset + 1] << 8) |
    (blob[offset + 2] << 16) |
    (blob[offset + 3] << 24)
  ) >>> 0; // coerce to uint
}

function readuint16le(offset, blob) {
  return (blob[offset] | (blob[offset + 1] << 8)) & 0xFFFF;
}

function readfloat32le(offset, blob) {
  const dv = new DataView(blob.buffer, blob.byteOffset, blob.byteLength);
  return dv.getFloat32(offset, true); // true = le
}
function lzssDecompress(data) { // my terrible implementation (in a previous version this comment had a spelling error, I know a certain person who im surprised didnt correct me on it lmao)
  const output = [];
  let p = 4, op = 0, mask = 0, flag = 0;
  while (p < data.length) {
    if (mask === 0) { flag = data[p++]; mask = 0x80; }
    if ((flag & mask) === 0) { output.push(data[p++]); op++; } 
    else {
      if (p + 1 >= data.length) break;
      const dat = (data[p]<<8)|data[p+1]; p+=2;
      const pos = (dat & 0x0FFF) + 1;
      const length = (dat >> 12) + 3;
      for(let i=0;i<length;i++) { output.push(op-pos>=0?output[op-pos]:0); op++; }
    }
    mask >>= 1;
  }
  return new Uint8Array(output);
}

function readLE32(buf, off){ return buf[off]|(buf[off+1]<<8)|(buf[off+2]<<16)|(buf[off+3]<<24); } // cant even make my code clear smh
function readF32(buf, off){ return new DataView(buf.buffer).getFloat32(off,true); }
function decompressXCL(data) { // xcl? More like, uh...
  if (data.length < 4) throw new Error("File too small for XCL header"); // ...yeah. - by woganog :D
  const header = data.subarray(0,4); // Excel - by doggo who proceeded to suggest we all become comp excel users :sob: (my next project frfr)

  const method = header[0] & 0x7;
  const size = ((header[0] >> 3) | (header[1]<<5) | (header[2]<<13) | (header[3]<<21)) >>> 0;

  let decomp;
  if (method === 0) {
    decomp = data.subarray(4);  // raw
  } else if (method === 1) {
    decomp = lzssDecompress(data); // LZSS
  } else {
    throw new Error(`Unsupported compression method ${method}. Only raw (0) and LZSS (1) supported.`);
  }

  if (decomp.length !== size) { // crash out
    console.warn(`Warning: decompressed size (${decomp.length}) does not match header size (${size})`);
  }
  return decomp;
}

function parseXCL(decomp){
  const vertices = [], indices = [], log = [];
 // const vertexOffsetRel = 0x00; // readLE32(decomp, 0x08); // archiving my s ...

  const mainaddr = readuint32le(0x08, decomp); 
  let len = readuint32le(0x4C, decomp);
  len = len === 0 ? readuint32le(0x58, decomp) : len;

  // Use the vertex data starting at mainaddr
  const vertDataStart = mainaddr;
  const vertDataEnd = mainaddr + len;

  const triOffsetRel = vertDataEnd;
  const triEndRel = triOffsetRel + len; //readLE32(decomp, 0x14); // I havent fully found out where this is - but this is a safe bet; it will skip a few but ill fix it later

  const triOffset = triOffsetRel;
  const triEnd = triEndRel;

  log.push(`Vertices start at 0x${vertDataStart.toString(16)}`); // coolz
  log.push(`Triangles start at 0x${triOffsetRel.toString(16)}, end at 0x${triEnd.toString(16)}`);

  // parse vertices
  for (let off = vertDataStart; off + 12 <= vertDataEnd && off + 12 <= decomp.length; off += 12) {
    const x = readfloat32le(off, decomp),
          y = readfloat32le(off + 4, decomp),
          z = readfloat32le(off + 8, decomp);
    vertices.push([x, y, z]);
  }

  log.push(`Parsed ${vertices.length} vertices`);

  // Parse triangles
  let off = triOffset;
  while (off + 6 <= triEnd && off + 6 <= decomp.length) {
    const i0 = decomp[off] | (decomp[off+1]<<8),
          i1 = decomp[off+2] | (decomp[off+3]<<8),
          i2 = decomp[off+4] | (decomp[off+5]<<8);
    if (i0 < vertices.length && i1 < vertices.length && i2 < vertices.length) {
      indices.push([i0, i1, i2]);
    }
    off += 6;
  }
  log.push(`Parsed ${indices.length} triangles`);

  return {vertices, indices, log: log.join('\n')};
}

document.getElementById('fileInput').addEventListener('change', async(ev)=>{
  const file=ev.target.files[0]; 
  if(!file) return;
  const logDiv = document.getElementById('log');
  logDiv.textContent = '';

  try {
    const buf=new Uint8Array(await file.arrayBuffer());
    const decomp = decompressXCL(buf);
    const parsed = parseXCL(decomp);
    logDiv.textContent = parsed.log;

    const btn=document.getElementById('exportBtn');
    btn.disabled=false;
    document.getElementById('exportBtn').onclick = () => {
  const showVertices = document.getElementById('showVertices').checked;
  const showTriangles = document.getElementById('showTriangles').checked;

  let objText = '';

  if (showVertices) {
    parsed.vertices.forEach(v => {
      objText += `v ${v[0]} ${v[1]} ${v[2]}\n`;
    });
  }

  if (showTriangles) {
    parsed.indices.forEach(t => {
      objText += `f ${t[0]+1} ${t[1]+1} ${t[2]+1}\n`;
    });
  }

  objText += '# n123, hearty, light and math are goated!! except n123 isnt :< \n';

  const blob = new Blob([objText], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = file.name + '.obj';
  a.click();
};

  } catch(err) {
    logDiv.textContent = 'Error: ' + err.message;
    document.getElementById('exportBtn').disabled = true;
  }
});
</script>
</body>
</html>
